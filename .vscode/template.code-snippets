{
    "codeforces": {
        "scope": "cpp",
        "prefix": "codeforces",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#ifdef LOCAL",
            "#include \"lib/local.h\"",
            "local_initialer _li(\"in.txt\", \"out.txt\");",
            "#else",
            "void debug(...) {} void utime() {}",
            "#endif",
            "using ll = long long;",
            "namespace solver",
            "{",
            "\ttemplate <typename C, typename T, ranges::range R>",
            "\tauto& operator<<(basic_ostream<C,T>& os, const R& rg)",
            "\t{",
            "\t\tranges::copy(rg, ostream_iterator<ranges::range_value_t<R>, C, T>(os, \" \"));",
            "\t\treturn os;",
            "\t}",
            "\tconst bool MULTICASES = true;",
            "\tconst char* const BOOLMSG[] = {\"No\", \"Yes\"};",
            "\tauto solve([[maybe_unused]] const int kase)",
            "\t{",
            "\t\t$0",
            "\t}",
            "};",
            "using namespace solver;",
            "int main()",
            "{",
            "\tcin.tie(nullptr)->sync_with_stdio(false);",
            "\tauto solver = [&]<typename F, typename R=invoke_result_t<F, int>>(F&& solve)",
            "\t{",
            "\t\tint t = 1;",
            "\t\tif constexpr(MULTICASES) cin>>t;",
            "\t\tfor(int i=1;i<=t;i++)",
            "\t\t{",
            "\t\t\tif constexpr(same_as<R, void>) solve(i);",
            "\t\t\telse if constexpr(same_as<R, bool>) cout<<BOOLMSG[solve(i)]<<'\\n';",
            "\t\t\telse cout<<solve(i)<<'\\n';",
            "\t\t}",
            "\t};",
            "\tsolver(solve);",
            "}",
            ""
        ]
    },
    "simple": {
        "scope": "cpp",
        "prefix": "simple",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "int main()",
            "{",
            "#ifdef LOCAL",
            "\tfreopen(\"in.txt\", \"r\", stdin);",
            "\tfreopen(\"out.txt\", \"w\", stdout);",
            "#endif",
            "\tcin.tie(nullptr)->sync_with_stdio(false);",
            "\t$0",
            "}",
            ""
        ]
    },
    "myclass": {
        "scope": "cpp",
        "prefix": "myclass",
        "body": [
            "#include <iostream>",
            "using namespace std;",
            "int main()",
            "{",
            "\t$0",
            "\treturn 0;",
            "}",
            ""
        ]
    },
    "leetcode": {
        "scope": "cpp",
        "prefix": "leetcode",
        "body": [
            "#ifdef LOCAL",
            "#include \"lib/leetcode.h\"",
            "#endif",
            "using ll = long long;",
            "class Solution",
            "{",
            "public:",
            "\tauto solve()",
            "\t{",
            "\t\t$0",
            "\t}",
            "};",
            "#ifdef LOCAL",
            "LEETCODE_MAIN(solve);",
            "#endif",
            ""
        ]
    },
    "vector_n_0": {
        "scope": "cpp",
        "prefix": "vn0",
        "body": [
            "vector<int> ${a}(${n});"
        ]
    },
    "vector_n_1": {
        "scope": "cpp",
        "prefix": "vn1",
        "body": [
            "vector<int> ${a}(${n}+1);"
        ]
    },
    "input_vector_n_0": {
        "scope": "cpp",
        "prefix": "ivn0",
        "body": [
            "for(int i=0;i<${n};i++) cin>>${a}[i];"
        ]
    },
    "input_vector_n_1": {
        "scope": "cpp",
        "prefix": "ivn1",
        "body": [
            "for(int i=1;i<=${n};i++) cin>>${a}[i];"
        ]
    },
    "output_vector_n_0": {
        "scope": "cpp",
        "prefix": "ovn0",
        "body": [
            "for(int i=0;i<${n};i++) cout<<${a}[i]<<\" \\n\"[i==${n}-1];"
        ]
    },
    "output_vector_n_1": {
        "scope": "cpp",
        "prefix": "ovn1",
        "body": [
            "for(int i=1;i<=${n};i++) cout<<${a}[i]<<\" \\n\"[i==${n}];"
        ]
    },
    "vector_nm_0": {
        "scope": "cpp",
        "prefix": "vnm0",
        "body": [
            "vector ${a}(n, vector<int>(m));"
        ]
    },
    "vector_nm_1": {
        "scope": "cpp",
        "prefix": "vnm1",
        "body": [
            "vector ${a}(n+1, vector<int>(m+1));"
        ]
    },
    "input_vector_nm_0": {
        "scope": "cpp",
        "prefix": "ivnm0",
        "body": [
            "for(int i=0;i<n;i++)",
            "\tfor(int j=0;j<m;j++)",
            "\t\tcin>>${a}[i][j];",
        ]
    },
    "input_vector_nm_1": {
        "scope": "cpp",
        "prefix": "ivnm1",
        "body": [
            "for(int i=1;i<=n;i++)",
            "\tfor(int j=1;j<=m;j++)",
            "\t\tcin>>${a}[i][j];",
        ]
    },
    "output_vector_nm_0": {
        "scope": "cpp",
        "prefix": "ovnm0",
        "body": [
            "for(int i=0;i<n;i++)",
            "\tfor(int j=0;j<m;j++)",
            "\t\tcout<<${a}[i][j]<<\" \\n\"[j==m-1];",
        ]
    },
    "output_vector_nm_1": {
        "scope": "cpp",
        "prefix": "ovnm1",
        "body": [
            "for(int i=1;i<=n;i++)",
            "\tfor(int j=1;j<=m;j++)",
            "\t\tcout<<${a}[i][j]<<\" \\n\"[j==m];",
        ]
    },
    "isort": {
        "scope": "cpp",
        "prefix": "isort",
        "body": [
            "vector<int> o(n);",
            "iota(o.begin(), o.end(), 0);",
            "ranges::sort(o, [&](int i, int j) { return a[i]<a[j]; });"
        ]
    },
    "mcnt": {
        "scope": "cpp",
        "prefix": "mcnt",
        "body": [
            "map<decltype(a)::value_type, int> cnt;",
            "for(auto i : a) cnt[i]++;"
        ]
    },
    "comb": {
        "scope": "cpp",
        "prefix": "comb",
        "body": [
            "vector<mint> fac, ifac;",
            "mint A(int n, int m)",
            "{",
            "\tif(m<0||m>n) return 0;",
            "\twhile((int)fac.size()<n+1)",
            "\t{",
            "\t\tif(fac.empty()) fac = ifac = {1};",
            "\t\telse",
            "\t\t{",
            "\t\t\tfac.push_back(fac.back()*fac.size());",
            "\t\t\tifac.push_back(1/fac.back());",
            "\t\t}",
            "\t}",
            "\treturn fac[n]*ifac[n-m];",
            "}",
            "mint C(int n, int m)",
            "{",
            "\tauto a = A(n, m);",
            "\treturn a==0?0:a*ifac[m];",
            "}"
        ]
    },
    "tree": {
        "scope": "cpp",
        "prefix": "tree",
        "body": [
            "vector<vector<int>> G(n+1);",
            "for(int i=1;i<n;i++)",
            "{",
            "\tint u,v;",
            "\tcin>>u>>v;",
            "\tG[u].push_back(v);",
            "\tG[v].push_back(u);",
            "}"
        ]
    },
    "graph": {
        "scope": "cpp",
        "prefix": "graph",
        "body": [
            "vector<vector<int>> G(n+1);",
            "for(int i=0;i<m;i++)",
            "{",
            "\tint u,v;",
            "\tcin>>u>>v;",
            "\tG[u].push_back(v);",
            "\tG[v].push_back(u);",
            "}"
        ]
    },
    "graph_w": {
        "scope": "cpp",
        "prefix": "graph_w",
        "body": [
            "vector<vector<pair<int,int>>> G(n+1);",
            "for(int i=0;i<m;i++)",
            "{",
            "\tint u,v,w;",
            "\tcin>>u>>v>>w;",
            "\tG[u].emplace_back(v,w);",
            "\tG[v].emplace_back(u,w);",
            "}"
        ]
    },
    "chmin": {
        "scope": "cpp",
        "prefix": "chmin",
        "body": [
            "template <typename T, typename U, typename C=common_type_t<T,U>>",
            "auto chmin(T& a, const U& b) { return C(b)<C(a)&&(a=b,true); }"
        ]
    },
    "chmax": {
        "scope": "cpp",
        "prefix": "chmax",
        "body": [
            "template <typename T, typename U, typename C=common_type_t<T,U>>",
            "auto chmax(T& a, const U& b) { return C(b)>C(a)&&(a=b,true); }"
        ]
    },
    "div_ceil": {
        "scope": "cpp",
        "prefix": "div_ceil",
        "body": [
            "template <integral T, integral U, typename C=common_type_t<T,U>>",
            "auto div_ceil(T a, U b) { auto [p,q] = div(C(a), C(b)); return p+!!q; }"
        ]
    },
    "dfs": {
        "scope": "cpp",
        "prefix": "dfs",
        "body": [
            "auto dfs = [&](this auto dfs,int u,int f) -> void",
            "{",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(v==f) continue;",
            "\t\tdfs(v,u);",
            "\t}",
            "};",
            "dfs(1,0);"
        ]
    },
    "hasher": {
        "scope": "cpp",
        "prefix": "hasher",
        "body": [
            "struct hasher",
            "{",
            "\tstatic uint64_t splitmix64(uint64_t x)",
            "\t{",
            "\t\tx += 0x9e3779b97f4a7c15;",
            "\t\tx = (x^(x>>30))*0xbf58476d1ce4e5b9;",
            "\t\tx = (x^(x>>27))*0x94d049bb133111eb;",
            "\t\treturn x^(x>>31);",
            "\t}",
            "\tsize_t operator()(uint64_t x) const ",
            "\t{",
            "\t\tstatic const uint64_t fix = chrono::steady_clock::now().time_since_epoch().count();",
            "\t\treturn splitmix64(x+fix);",
            "\t}",
            "};"
        ]
    },
    "erfen": {
        "scope": "cpp",
        "prefix": "erfen",
        "body": [
            "auto check = [&](auto g) -> bool",
            "{",
            "\t$3",
            "};",
            "auto res = *ranges::partition_point(views::iota($1, $2), check);"
        ]
    },
    "sanfen": {
        "scope": "cpp",
        "prefix": "sanfen",
        "body": [
            "ll l=1, r=1e9;",
            "while(l<r)",
            "{",
            "\tauto ml=l+(r-l)/3, mr=r-(r-l)/3;",
            "\tauto fl=f(ml), fr=f(mr);",
            "\tif(fl<=fr)",
            "\t{",
            "\t\tchmin(ans, fl);",
            "\t\tr = mr-1;",
            "\t}",
            "\telse",
            "\t{",
            "\t\tchmin(ans, fr);",
            "\t\tl = ml+1;",
            "\t}",
            "}",
            "return ans;"
        ]
    },
    "modui": {
        "scope": "cpp",
        "prefix": "modui",
        "body": [
            "vector<pair<int,int>> q(m);",
            "for(int i=0;i<m;i++) cin>>q[i].first>>q[i].second;",
            "int siz = n/sqrt(m)+1;",
            "vector<int> pos(n+1);",
            "for(int i=1;i<=n;i++) pos[i] = i/siz;",
            "ll res = 0;",
            "auto add = [&](int p)",
            "{",
            "};",
            "auto del = [&](int p)",
            "{",
            "};",
            "vector<int> o(m);",
            "iota(o.begin(), o.end(), 0);",
            "ranges::sort(o, [&](int i, int j) {",
            "\tauto [l1,r1] = q[i];",
            "\tauto [l2,r2] = q[j];",
            "\treturn pos[l1]==pos[l2]",
            "\t\t? r1==r2?false:((pos[l1]&1)^(r1<r2))",
            "\t\t: l1<l2;",
            "});",
            "vector<ll> ans(m);",
            "int l=1, r=0;",
            "for(auto i : o)",
            "{",
            "\tauto [L,R] = q[i];",
            "\twhile(L<l) add(--l);",
            "\twhile(R>r) add(++r);",
            "\twhile(L>l) del(l++);",
            "\twhile(R<r) del(r--);",
            "\tans[i] = res;",
            "}",
            "for(int i=0;i<m;i++) cout<<ans[i]<<'\\n';"
        ]
    },
    "digitdp": {
        "scope": "cpp",
        "prefix": "digitdp",
        "body": [
            "auto f = [&](ll x) -> ll // [1,x]",
            "{",
            "\tvector<int> a;",
            "\tfor(auto c : to_string(x)) a.push_back(c-'0');",
            "\tmdarray<optional<ll>, 20, 10, 2, 2> dp;",
            "\t// 到第 p 位，x 代表到当前位时 {?}，前一位是否顶着上界(lim)，前一位是不是前导零(zero)",
            "\tauto dfs = [&](this auto dfs, size_t p, int x, bool lim, bool zero) -> ll",
            "\t{",
            "\t\tif(p==a.size()) return /* {确定一个解对答案的贡献} */;",
            "\t\tif(dp[p][x][lim][zero]) return *dp[p][x][lim][zero];",
            "\t\tll res = 0;",
            "\t\tfor(int i=zero;i<=(lim?a[p]:9);i++) // 第 p 位取 i",
            "\t\t{",
            "\t\t\t/* {确定是否需要筛选 i} */",
            "\t\t\tres += dfs(p+1, /* {确定 x 的变化} */, lim&&i==a[p], false);",
            "\t\t}",
            "\t\tdp[p][x][lim][zero] = res;",
            "\t\treturn res;",
            "\t};",
            "\tll ret = 0;",
            "\tfor(size_t i=0;i<a.size();i++)  // 第 i 位是第一个非 0 的",
            "\t\tret += dfs(i, /* {x 的初始值} */, !i, true);",
            "\treturn ret;",
            "};"
        ]
    },
    "hjt": {
        "scope": "cpp",
        "prefix": "hjt",
        "body": [
            "struct Node { int l,r,val; };",
            "vector<Node> t(m*(ceil(log2(n))+1));",
            "vector<int> root(n+1);",
            "int cnt = 0;",
            "auto ins = [&](auto&& ins, int l,int r,int pre,int& k,int x)",
            "{",
            "\tk = ++cnt;",
            "\tt[k] = t[pre];",
            "\tt[k].val++;",
            "\tif(l==r) return;",
            "\tint m = (l+r)>>1;",
            "\tif(x<=m) ins(ins,l,m,t[pre].l,t[k].l,x);",
            "\telse ins(ins,m+1,r,t[pre].r,t[k].r,x);",
            "};",
            "auto query = [&](this auto query,int l,int r,int L,int R,int x,int y)",
            "{",
            "\tif(x<=l&&y>=r) return t[R].val-t[L].val;",
            "\tint m = (l+r)>>1;",
            "\tint sum = 0;",
            "\tif(x<=m) sum += query(l,m,t[L].l,t[R].l,x,y);",
            "\tif(y>m) sum += query(m+1,r,t[L].r,t[R].r,x,y);",
            "\treturn sum;",
            "};"
        ]
    },
    "dsuontree": {
        "scope": "cpp",
        "prefix": "dsuontree",
        "body": [
            "int tim = 0;",
            "vector<int> siz(n+1), son(n+1), dfn(n+1), id(n+1);",
            "auto dfs1 = [&](this auto dfs1,int u,int f) -> void",
            "{",
            "\tsiz[u] = 1;",
            "\tdfn[u] = ++tim;",
            "\tid[tim] = u;",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(v==f) continue;",
            "\t\tdfs1(v,u);",
            "\t\tsiz[u] += siz[v];",
            "\t\tif(siz[v]>siz[son[u]]) son[u] = v;",
            "\t}",
            "};",
            "auto add = [&](int u)",
            "{",
            "};",
            "auto del = [&](int u)",
            "{",
            "};",
            "auto dfs2 = [&](this auto dfs2,int u,int f,bool keep) -> void",
            "{",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(v==f||v==son[u]) continue;",
            "\t\tdfs2(v,u,false);",
            "\t}",
            "\tif(son[u]) dfs2(son[u],u,true);",
            "\tadd(u);",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(v==f||v==son[u]) continue;",
            "\t\tfor(int i=dfn[v];i<dfn[v]+siz[v];i++)",
            "\t\t\tadd(id[i]);",
            "\t}",
            "\tans[u] = sum;",
            "\tif(!keep)",
            "\t{",
            "\t\tfor(int i=dfn[u];i<dfn[u]+siz[u];i++)",
            "\t\t\tdel(id[i]);",
            "\t}",
            "};",
            "dfs1(1,0);",
            "dfs2(1,0,false);"
        ]
    },
    "centroid_decomposition": {
        "scope": "cpp",
        "prefix": "centroid_decomposition",
        "body": [
            "int part=n, cent=0;",
            "vector<int> siz(n+1), maxp(n+1);",
            "vector<bool> del(n+1);",
            "auto get_cent = [&](this auto get_cent,int u,int f) -> void",
            "{",
            "\tsiz[u] = 1;",
            "\tmaxp[u] = 0;",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(v==f||del[v]) continue;",
            "\t\tget_cent(v,u);",
            "\t\tsiz[u] += siz[v];",
            "\t\tmaxp[u] = max(maxp[u], siz[v]);",
            "\t}",
            "\tmaxp[u] = max(maxp[u], part-siz[u]);",
            "\tif(maxp[u]<maxp[cent]) cent = u;",
            "};",
            "auto dfs = [&](this auto dfs,int u,int f) -> void",
            "{",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(v==f||del[v]) continue;",
            "\t\tdfs(v,u);",
            "\t}",
            "};",
            "auto calc = [&](this auto calc,int u)",
            "{",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(del[v]) continue;",
            "\t\tdfs(v,u);",
            "\t}",
            "};",
            "auto divide = [&](this auto divide,int u) -> void",
            "{",
            "\tdel[u] = true;",
            "\tcalc(u);",
            "\tfor(auto v : G[u])",
            "\t{",
            "\t\tif(del[v]) continue;",
            "\t\tmaxp[cent=0] = part = siz[v];",
            "\t\tget_cent(v,0);",
            "\t\tget_cent(cent,0);",
            "\t\tdivide(cent);",
            "\t}",
            "};",
            "maxp[cent] = n;",
            "get_cent(1,0);",
            "get_cent(cent,0);",
            "divide(cent);"
        ]
    },
    "dijkstra": {
        "scope": "cpp",
        "prefix": "dijkstra",
        "body": [
            "auto dijkstra = [&](int s)",
            "{",
            "\tvector<ll> dis(n+1, 1e18);",
            "\tdis[s] = 0;",
            "\tpriority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<>> pq;",
            "\tpq.emplace(0, s);",
            "\twhile(!pq.empty())",
            "\t{",
            "\t\tauto [d,u] = pq.top();",
            "\t\tpq.pop();",
            "\t\tif(d>dis[u]) continue;",
            "\t\tfor(auto [v,w] : G[u])",
            "\t\t{",
            "\t\t\tif(dis[v]>dis[u]+w)",
            "\t\t\t{",
            "\t\t\t\tdis[v] = dis[u]+w;",
            "\t\t\t\tpq.emplace(dis[v], v);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn dis;",
            "};"
        ]
    }
}
