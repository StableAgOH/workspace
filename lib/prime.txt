const int N = sqrt(1e7)+1;
vector<int> pri;
vector<bool> vis(N+1);
for(int i=2;i<=N;i++)
{
    if(!vis[i]) pri.push_back(i);
    for(int j : pri)
    {
        if((ll)i*j>N) break;
        vis[i*j] = true;
        if(i%j==0) break;
    }
}
debug(N, pri.size());

auto pfac_vec = [&]<typename T>(T x)
{
    vector<T> v;
    for(auto i : pri)
    {
        if(x%i==0) v.push_back(i);
        while(x%i==0) x /= i;
    }
    if(x>1) v.push_back(x);
    return v;
};

auto pfac_mp = [&]<typename T>(T x)
{
    map<T,int> mp;
    for(auto i : pri)
    {
        while(x%i==0)
        {
            mp[i]++;
            x /= i;
        }
    }
    if(x>1) mp[x]++;
    return mp;
};

auto pfac_pairvec = [&]<typename T>(T x)
{
    map<T,int> mp;
    for(auto i : pri)
    {
        while(x%i==0)
        {
            mp[i]++;
            x /= i;
        }
    }
    if(x>1) mp[x]++;
    return vector(mp.begin(), mp.end());
};

// 枚举 z 的所有因子（除了 1）
auto pf = pfac_pairvec(z);
decltype(z) mul = 1;
vector<decltype(z)> fac;
function<void(size_t)> dfs = [&](size_t p)
{
    if(p==pf.size()) return;
    dfs(p+1);
    auto [a,b] = pf[p];
    for(int i=0;i<b;i++)
    {
        mul *= a;
        fac.push_back(mul);
        dfs(p+1);
    }
    for(int i=0;i<b;i++) mul /= a;
};
dfs(0);
//* result: fac
